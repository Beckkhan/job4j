Источник: https://habr.com/ru/post/134102/

JVM хранит для каждого объекта:

1) Заголовок объекта (Каждый заголовок для большинства JVM(Hotspot, openJVM) состоит из двух машинных слов.
Если речь идет о 32-х разрядной системе, то размер заголовка — 8 байт,
если речь о 64-х разрядной системе, то соответственно — 16 байт.);
2) Память для примитивных типов;
3) Память для ссылочных типов;
4) Смещение/выравнивание: это несколько неиспользуемых байт, что размещаются после данных самого объекта.
Это сделано для того, чтобы адрес в памяти всегда был кратным машинному слову для ускорения чтения из памяти +
для уменьшения количества бит для указателя на объект + 
для уменьшения фрагментации памяти.

Стоит также отметить, что в java размер любого объекта кратен 8 байтам!

Объект класса Integer в нашей 64-х разрядной JVM:
Заголовок: 16 байт
Поле int: 4 байта
Выравнивание для кратности 8 : 4 байта
Итого: 24 байта

Теперь заглянем в класс String:
private final char value[];
private final int offset;
private final int count;
private int hash;
	
В 64-х разрядных JVM размер ссылки обычно равен 8 байт.
Обратимся к строке String и подсчитаем размер:
Заголовок: 16 байт
Поля int: 4 байта * 3 == 12 байт
Ссылочная переменная на объект массива: 8 байт.
Выравнивание для кратности 8 : 4 байта.
Итого: 40 байт

Объект класса User:
Заголовок: 16 байт
Поле Integer: 24 байта
Поле String: 40 байт +...размер массива, который содержит символы, считаем их далее...

Теперь подсчитаем размер массива, который содержит символы.
Отметим, что у нас создаются объекты, в которых количество символов в имени будет увеличиваться
по мере создания новых объектов, т.к. для наглядности в программе использовался цикл for с инкрементацией i.
Соответственно, у нас будут создаваться объекты new User(), занимающие разные объемы памяти.
Рассмотрим все варианты.

1) i=1, для объекта, где строка с именем состоит из одного символа
new char[1]
Заголовок: 16 байт + 4 байта на длину массива == 20 байт (Array Length — если объект — массив,
то заголовок расширяется 4 байтами для хранения длины массива.)
Примитивы char: 2 байта * 1 == 2 байта
Выравнивание для кратности 8 : 2 байта
Итого: 16 байта
Получаем размер объекта String, где строка с именем состоит из одного символа 40 байт + 16 = 56 байт.

Этот расчет приведен в качестве примера для дальнейшего подсчета.

2) 1<= i <=9, для объекта, где строка с именем состоит из 9 символов "User No.i" для i от 1 до 9
new char[9]
Заголовок: 16 байт + 4 байта на длину массива == 20 байт
Примитивы char: 2 байта * 9 == 18 байтов
Выравнивание для кратности 8 : 2 байта
Итого: 40 байт
Получаем размер объекта String, где строка с именем состоит из 9 символов: 40 байт + 40 = 80 байт.

Таких объектов у нас создается 9.
Получаем, что один объект new User(("User No." + i), Integer.valueOf(i * 1000)), где i в диапазоне 1<= i <=9,
будет занимать 16 + 24 + 80 = 120 байт.
В сумме эти 9 объектов будут занимать память объемом: 9 * 120 = 1080 байт.

3) 10<= i <=99, для объекта, где строка с именем состоит из 10 символов "User No.i"
new char[10]
Заголовок: 16 байт + 4 байта на длину массива == 20 байт
Примитивы char: 2 байта * 10 == 20 байтов
Выравнивание для кратности 8 : 0 байт, т.к. выше мы уже получаем сумму в 40 байт, кратную 8.
Итого: 40 байт
Получаем размер объекта String, где строка с именем состоит из 10 символов: 40 байт + 40 = 80 байт.

Таких объектов у нас создается 90.
Получаем, что один объект new User(("User No." + i), Integer.valueOf(i * 1000)), где i в диапазоне 10<= i <=99,
будет занимать 16 + 24 + 80 = 120 байт.
В сумме эти 90 объектов будут занимать память объемом: 90 * 120 = 10800 байт.

3) 100<= i <=999, для объекта, где строка с именем состоит из 11 символов "User No.i"
new char[11]
Заголовок: 16 байт + 4 байта на длину массива == 20 байт
Примитивы char: 2 байта * 11 == 22 байта
Выравнивание для кратности 8 : 6 байт
Итого: 48 байт
Получаем размер объекта String, где строка с именем состоит из 11 символов: 40 байт + 48 = 88 байт.

Таких объектов у нас создается 900.
Получаем, что один объект new User(("User No." + i), Integer.valueOf(i * 1000)), где i в диапазоне 100<= i <=999,
будет занимать 16 + 24 + 88 = 128 байт.
В сумме эти 900 объектов будут занимать память объемом: 900 * 128 = 115200 байт.

3) 1000<= i <=5000, для объекта, где строка с именем состоит из 12 символов "User No.i"
new char[11]
Заголовок: 16 байт + 4 байта на длину массива == 20 байт
Примитивы char: 2 байта * 12 == 24 байта
Выравнивание для кратности 8 : 4 байт
Итого: 48 байт
Получаем размер объекта String, где строка с именем состоит из 12 символов: 40 байт + 48 = 88 байт.

Таких объектов у нас создается 4001.
Получаем, что один объект new User(("User No." + i), Integer.valueOf(i * 1000)), где i в диапазоне 100<= i <=999,
будет занимать 16 + 24 + 88 = 128 байт.
В сумме эти 4001 объект будут занимать память объемом: 4001 * 128 = 512128 байт.

В итоге создается 5000 тысяч объектов класса User, которые занимают объем: 1080 + 10800 + 115200 + 512128 = 639208 байт, или 0,6095 Мегабайт.

С помощью ключей xmx установлено ограничение доступной для программы памяти в 4 Мб.
В программе использовался цикл for с инкрементацией индекса для создания объектов класса User и выведением их в консоль.
В условиях ограничения доступной памяти JVM сама вызывает GC для удаления неиспользуемых объектов.
В классе User переопределен метод finalize(), который выводит сообщение при удалении объекта из памяти Heap.

При увеличении порога инкрементации индекса i, т.е. при увеличении количества создаваемых объектов,
выбрасывается исключения java.lang.OutOfMemoryError, что говорит нам об исчерпании памяти, выделенной для исполнения программы.